.lazy:

HOME >home
END >end
LEFT <N
RIGHT >N
UP `N
DOWN .N

.normal_movement:

0 >home
$ >end
G $end
g g `home .N & `1
g G .end `N & .1
BACK $-N
SPACE $N
^J .1 & >home
h <N
l >N
k `N
j .N

normal: lazy, normal_movement

^W h <wN
^W j .wN
^W k `wN
^W l >wN
^W SPACE $wN
^W BACK $w-N
^W n !new
O >home +\n $-N
o >end +\n :insert
I >home :insert
A >end :insert
i :insert
r >xN :insert
a $1 :insert
d l, x, DEL >xN
d h, X <xN
d D `xN
d d .xN
d k `x1 `xN
d j .x1 .xN
p !paste
u !undo
^R !redo
v :visual
: w !write
: q !close
: q a !quit

$insert: lazy

BACK <x1
DEL >x1
##^A $home :visual $end
ESC :normal

## some tests for interactive coding
i f ( +) $-1
i f { <x1 +"() {\n}" $-5
m a i n <x4 +"int\nmain(int argc, char **argv)\n{\n\treturn 0;\n}"
w h i l e ( 1 ) <x8 +for(;;)
^W b e g <x3 $home
^W e n d <x3 $end

visual*: lazy, normal_movement

ESC, v :normal
x, X, d, D !delete :normal
y !copy :normal

